Ниже — краткие описания каждой статьи.

Статья №1: Improving Jump Point Search (Harabor, Grastien)
- Идея: ускорить JPS за счет (1) блочного (бит-параллельного) сканирования строк/столбцов, (2) офлайн-предобработки jump‑точек (JPS+), (3) улучшенного онлайн-отсечения промежуточных jump‑точек.
- Как работает:
  - Блочное сканирование: вместо проверки узлов по одному читают целые машинные слова/байты и за счет побитовых операций быстро находят «остановки» (повороты, тупики, форсированные соседи).
  - Предобработка (JPS+): для каждой клетки и 8 направлений заранее сохраняют первую достижимую jump‑точку (и «стерильные» — для корректной обработки цели на лету). Доступ к преемникам — O(1).
  - Улучшенное отсечение: промежуточные (не у препятствий) jump‑точки не расширяются; их прямые преемники генерируются сразу.
- Результаты: ускорения относительно JPS 2011 от нескольких раз до >10×; JPS+ часто быстрее современных SUB (subgoal graphs) или сопоставим. Предобработка обычно занимает миллисекунды–сотни миллисекунд и до нескольких–десятков МБ.
- Плюсы/минусы: значительный выигрыш во времени; JPS (B) и JPS (B+P) — онлайн и без памяти; JPS+ быстрее, но требует памяти и пересчета при изменении карты.

Статья №2: Optimal Pathfinding on Weighted Grid Maps (Carlson et al.) — Weighted JPS (JPSW)
- Идея: обобщить JPS на взвешенные решетки, где симметрии сохраняются не всегда. Вводится лексикографический «тай-брейк» (orthogonal-last): минимизируем (g, |последний ход|), что позволяет корректно отсекать симметричные варианты.
- Правила:
  - Прореживание преемников: в 3×3 окрестности вокруг узла с учетом направления родителя вычисляют минимальные по (g, |m|) пути (мини‑Дейкстра); оставляют те, где последний шаг из центра (кэширут для повторного использования).
  - Прыжки: продолжают, пока окрестность 3×3 однородна по типу террейна; на границе террейнов ставят точки остановки (иначе перепрыгнут важные развилки).
- Проблема overscan: при диагональных прыжках возникает массовое перекрывающееся ортогональное сканирование (квадратичная работа).
- Два решения:
  - Diagonal Branch Pruning: во время диагонального сканирования отключать лишние ортогональные ветви, если соответствующий ортогональный преемник уже отсечен.
  - Prospective g pruning: поддерживать «проспективные» g для клеток и отсекать сканы, если лучший известный g уже не улучшается; доказана сохранность оптимальности.
  - Плюс Jump Cache для ортогональных прыжков: кэширует длину и стоимость прыжка в каждом из 4 направлений; снижает худший случай до амортизированного O(n). Есть стратегии инвалидирования при динамике.
- Эксперименты (синтетика, города, multi‑terrain, «стражи»): базовый JPSW без прунинга может быть хуже A*, но с Pruning и/или Cache — ускорение до порядка величины над онлайн A*. Эффект коррелирует со средней длиной прыжков; при большом «шумах» весов (мало симметрий) выигрыш снижается.

Статья №3: Canonical Orderings on Grids (Sturtevant, Rabin)
- Идея: разложить JPS на три независимых компонента — best‑first поиск, канонический порядок ходов (диагонали раньше ортогоналей), и специальную функцию преемников (прыжки). Это позволяет конструировать семейство новых алгоритмов.
- Новые варианты:
  - Canonical A*: обычный A* + канонический порядок (без прыжков). Часть узлов не генерируется из‑за устранения симметрий; часто даёт ~половину выигрыша JPS.
  - Bounded JPS (BJPS): прыжки ограничены по дальности (порог b). Интерполирует между CA* (b=0) и JPS (b=∞); снижает издержки генерации в больших пустых областях, где JPS может генерировать O(r^2) клеток при идеальном эвристике.
  - Canonical Dijkstra (CD): вариант для single‑source; прыжки «проставляют» g на лету, переоткрывают jump‑точки при улучшениях. Даёт 2–4.4× ускорение SSSP.
  - Взвешенные (suboptimal) варианты для всех выше.
- Корректность: показано, что канонический порядок совместим с best‑first (не требуется хранить один и тот же узел с разными родительскими направлениями).
- Эксперименты: JPS выигрывает за счет сокращения операций с open, но платит большим числом «генераций»; CA* даёт существенный прирост дешевле; BJPS имеет «седловую» оптимальную дальность прыжков; CD заметно ускоряет SSSP.

Статья №4: Online Graph Pruning for Pathfinding on Grid Maps (Harabor, Grastien) — оригинальный JPS
- Идея: онлайн‑макрооператор для равновесных (uniform-cost) 8‑связных решеток, который расширяет не все клетки, а только jump‑точки; промежуточные клетки «перепрыгиваются».
- Механика:
  - Правила отсечения соседей зависят от направления входа; «естественные» соседи остаются, прочие отбрасываются, кроме «форсированных» (из‑за препятствий).
  - Функция jump рекурсивно двигается по направлению, останавливаясь на цели, при появлении форсированного соседа или на тупике; для диагонали обязательно проверяет ортогональные подскоки.
- Оптимальность: доказано через преобразование оптимального пути в «diagonal‑first» и соответствие поворотных точек jump‑точкам.
- Результаты: ускорение A* на порядок и более; заметное превосходство над Swamps (оптимальный прунинг областей) и сопоставимость/превосходство над HPA* (субоптимальный иерархический метод) при отсутствии предобработки и доп.памяти.
- Свойства: онлайн, оптимален, прост и без памяти/предобработки; хорошо комбинируется с другими ускорителями.